<application>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1681711470817" />
  </component>
  <component name="Translation.States">
    <histories>
      <item value="Specifies a JAR file with instrumentation classes to be defined by the bootstrap class loader. When the virtual machine's built-in class loader, known as the &quot;bootstrap class loader&quot;, unsuccessfully searches for a class, the entries in the JAR file will be searched as well. This method may be used multiple times to add multiple JAR files to be searched in the order that this method was invoked. The agent should take care to ensure that the JAR does not contain any classes or resources other than those to be defined by the bootstrap class loader for the purpose of instrumentation. Failure to observe this warning could result in unexpected behavior that is difficult to diagnose. For example, suppose there is a loader L, and L's parent for delegation is the bootstrap class loader. Furthermore, a method in class C, a class defined by L, makes reference to a non-public accessor class C1. If the JAR file contains a class C1 then the delegation to the bootstrap class loader will cause C1 to be defined by the bootstrap class loader. In this example an IllegalAccessError will be thrown that may cause the application to fail. One approach to avoiding these types of issues, is to use a unique package name for the instrumentation classes. The Java™ Virtual Machine Specification specifies that a subsequent attempt to resolve a symbolic reference that the Java virtual machine has previously unsuccessfully attempted to resolve always fails with the same error that was thrown as a result of the initial resolution attempt. Consequently, if the JAR file contains an entry that corresponds to a class for which the Java virtual machine has unsuccessfully attempted to resolve a reference, then subsequent attempts to resolve that reference will fail with the same error as the initial attempt." />
      <item value="Maps the specified key to the specified value in this table. Neither the key nor the value can be null. The value can be retrieved by calling the get method with a key that is equal to the original key." />
      <item value="Job is being rescaled." />
      <item value="Implements Map.putAll and Map constructor Params: m – the map evict – false when initially constructing this map, else true (relayed to method afterNodeInsertion)." />
      <item value="Computes key.hashCode() and spreads (XORs) higher bits of hash to lower. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don't benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds." />
      <item value="Any '%' found in the region starts an invalid format specifier." />
      <item value="Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. When using a capacity-restricted queue, this method is generally preferable to add, which can fail to insert an element only by throwing an exception. Params: e – the element to add" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="6" />
        <entry key="ENGLISH" value="7" />
      </map>
    </option>
  </component>
</application>