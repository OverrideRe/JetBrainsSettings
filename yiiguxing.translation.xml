<application>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1680864115802" />
  </component>
  <component name="Translation.States">
    <histories>
      <item value="Job is being rescaled." />
      <item value="Implements Map.putAll and Map constructor Params: m – the map evict – false when initially constructing this map, else true (relayed to method afterNodeInsertion)." />
      <item value="Computes key.hashCode() and spreads (XORs) higher bits of hash to lower. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don't benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds." />
      <item value="Any '%' found in the region starts an invalid format specifier." />
      <item value="Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. When using a capacity-restricted queue, this method is generally preferable to add, which can fail to insert an element only by throwing an exception. Params: e – the element to add" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="4" />
        <entry key="ENGLISH" value="5" />
      </map>
    </option>
  </component>
</application>